// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package blockchain

import (
	"log"
	"math"
	"mp2/utils"
	"os"
	"sync"
)

//cat generic_ccmap.go | genny gen "Key=string BlockchainTransaction=*blockchain.Transaction" > [targetName].go

// TransactionList the set of Items
type TransactionList struct {
	items             []Transaction
	TransactionStatus map[string]int // 0: uncommitted, 1: committed, 2: invalid
	lock              sync.RWMutex
}

// Set adds a new item to  the list
func (d *TransactionList) Append(v Transaction) {
	if d.Has(v.ID) {
		return
	}
	d.lock.Lock()
	defer d.lock.Unlock()
	if d.items == nil {
		d.items = make([]Transaction, 0)
		d.TransactionStatus = make(map[string]int)
	}
	targetIndex := d.findPositionUsingBinarySearch(v)

	if targetIndex >= 0 {
		d.items = append(d.items[:targetIndex], append([]Transaction{v}, d.items[targetIndex:]...)...)
	} else {
		d.items = append(d.items, v)
	}
	d.TransactionStatus[v.ID] = 0
}

func (d *TransactionList) findPositionUsingBinarySearch(v Transaction) int {
	L := 0
	R := len(d.items) - 1
	for {
		if L > R {
			break
		}
		m := int(math.Floor(float64(L+R) / 2.0))
		if d.items[m].Timestamp < v.Timestamp {
			L = m + 1
		} else if d.items[m].Timestamp > v.Timestamp {
			R = m - 1
		} else {
			log.Fatalln("transaction timestamp same, which shouldn't happen...")
			os.Exit(13)
		}
	}
	return L
}

// GetTransactionToCommit front
func (d *TransactionList) GetTransactionToCommit(n int) []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	var res []Transaction
	count := 0
	for _, tx := range d.items {
		if count < n && d.TransactionStatus[tx.ID] == 0 {
			res = append(res, tx)
			count += 1
		}
	}
	return res
}

func (d *TransactionList) CommitTransactions(tx []Transaction) {
	d.lock.Lock()
	defer d.lock.Unlock()
	for _, tx := range tx {
		d.TransactionStatus[tx.ID] = 1
	}
}

func (d *TransactionList) Size() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return len(d.TransactionStatus)
}

func (d *TransactionList) UncommittedSize() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	count := 0
	for _, tx := range d.TransactionStatus {
		if tx == 0 {
			count += 1
		}
	}
	return count
}

func (d *TransactionList) GetTransactSubset(num int) []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()

	tempArr := utils.Arange(0, d.Size(), 1)
	shuffledArr := utils.Shuffle(tempArr)

	res := make([]Transaction, 0)

	for _, v := range shuffledArr {
		if len(res) > num {
			break
		}
		res = append(res, d.items[v])
	}
	return res
}

func (d *TransactionList) Has(transactionID string) bool {
	d.lock.RLock()
	defer d.lock.RUnlock()
	_, ok := d.TransactionStatus[transactionID]
	return ok
}

func (d *TransactionList) SetTransaction(transaction Transaction, status string) bool {
	d.lock.Lock()
	defer d.lock.Unlock()
	_, ok := d.TransactionStatus[transaction.ID]
	if ok {
		if status == "uncommitted" {
			d.TransactionStatus[transaction.ID] = 0
		} else if status == "committed" {
			d.TransactionStatus[transaction.ID] = 1
		} else if status == "invalid" {
			d.TransactionStatus[transaction.ID] = 2
		}
	}
	return false
}

func (d *TransactionList) Delete(transactionID string) {
	d.lock.Lock()
	defer d.lock.Unlock()
	delete(d.TransactionStatus, transactionID)
}

func (d *TransactionList) GetTransactionList() []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return d.items
}
