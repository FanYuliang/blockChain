// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package blockchain

import (
	"math"
	"mp2/utils"
	"sync"
)

//cat generic_ccmap.go | genny gen "Key=string BlockchainTransaction=*blockchain.Transaction" > [targetName].go

// TransactionList the set of Items
type TransactionList struct {
	items             []Transaction
	transactionStatus map[string]int // 0: uncommitted, 1: committed, 2: invalid
	lock              sync.RWMutex
}

// Set adds a new item to  the list
func (d *TransactionList) Append(v Transaction) {
	d.lock.Lock()
	defer d.lock.Unlock()
	_, ok := d.transactionStatus[v.ID]
	if ok {
		return
	}
	if d.items == nil {
		d.items = make([]Transaction, 0)
		d.transactionStatus = make(map[string]int)
	}
	targetIndex := d.findPositionUsingBinarySearch(v)

	if targetIndex >= 0 {
		d.items = append(d.items[:targetIndex], append([]Transaction{v}, d.items[targetIndex:]...)...)
	} else {
		d.items = append(d.items, v)
	}
	d.transactionStatus[v.ID] = 0
}

func (d *TransactionList) findPositionUsingBinarySearch(v Transaction) int {
	L := 0
	R := len(d.items) - 1
	for {
		if L > R {
			break
		}
		m := int(math.Floor(float64(L+R) / 2.0))
		if d.items[m].Timestamp < v.Timestamp {
			L = m + 1
		} else if d.items[m].Timestamp > v.Timestamp {
			R = m - 1
		} else {
			return m
		}
	}
	return L
}

// GetTransactionToCommit front
func (d *TransactionList) GetTransactionToCommit(n int) []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	var res []Transaction
	count := 0
	for _, tx := range d.items {
		if count < n && d.transactionStatus[tx.ID] == 0 {
			res = append(res, tx)
			count += 1
		}
	}
	return res
}

func (d *TransactionList) CommitTransactions(tx []Transaction) {
	d.lock.Lock()
	defer d.lock.Unlock()
	for _, tx := range tx {
		d.transactionStatus[tx.ID] = 1
	}
}

func (d *TransactionList) Size() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return len(d.transactionStatus)
}

func (d *TransactionList) UncommittedSize() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	count := 0
	for _, tx := range d.transactionStatus {
		if tx == 0 {
			count += 1
		}
	}
	return count
}

func (d *TransactionList) GetTransactSubset(num int) []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()

	tempArr := utils.Arange(0, d.Size(), 1)
	shuffledArr := utils.Shuffle(tempArr)

	res := make([]Transaction, 0)

	for _, v := range shuffledArr {
		if len(res) > num {
			break
		}
		res = append(res, d.items[v])
	}
	return res
}

func (d *TransactionList) Has(transactionID string) bool {
	d.lock.RLock()
	defer d.lock.RUnlock()
	_, ok := d.transactionStatus[transactionID]
	return ok
}

func (d *TransactionList) SetTransaction(transactionID string, status string) bool {
	d.lock.Lock()
	defer d.lock.Unlock()
	if status == "uncommitted" {
		d.transactionStatus[transactionID] = 0
		return true
	} else if status == "committed" {
		d.transactionStatus[transactionID] = 1
		return true
	} else if status == "invalid" {
		d.transactionStatus[transactionID] = 2
		return true
	}
	return false
}

func (d *TransactionList) Delete(transactionID string) {
	d.lock.Lock()
	defer d.lock.Unlock()
	delete(d.transactionStatus, transactionID)
}

func (d *TransactionList) GetTransactionList() []Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return d.items
}
