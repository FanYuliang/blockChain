// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package ccmap

import (
	"mp2/blockchain"
	"sort"
	"sync"
)

// cat generic_ccmap.go | genny gen "String=string BlockchainTransaction=*blockchain.Transaction" > [targetName].go

// BlockchainTransactionDictionary the set of Items
type TransactionMap struct {
	items map[string]*blockchain.Transaction
	lock  sync.RWMutex
}

// Set adds a new item to the ccmap
func (d *TransactionMap) Set(k string, v *blockchain.Transaction) {
	d.lock.Lock()
	defer d.lock.Unlock()
	if d.items == nil {
		d.items = make(map[string]*blockchain.Transaction)
	}
	d.items[k] = v
}

// Delete removes a value from the ccmap, given its key
func (d *TransactionMap) Delete(k string) bool {
	d.lock.Lock()
	defer d.lock.Unlock()
	_, ok := d.items[k]
	if ok {
		delete(d.items, k)
	}
	return ok
}


// Has returns true if the key exists in the ccmap
func (d *TransactionMap) Has(k string) bool {
	d.lock.RLock()
	defer d.lock.RUnlock()
	_, ok := d.items[k]
	return ok
}

// Get returns the value associated with the key
func (d *TransactionMap) Get(k string) *blockchain.Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return d.items[k]
}

// Clear removes all the items from the ccmap
func (d *TransactionMap) Clear() {
	d.lock.Lock()
	defer d.lock.Unlock()
	d.items = make(map[string]*blockchain.Transaction)
}

// Size returns the amount of elements in the ccmap
func (d *TransactionMap) Size() int {
	d.lock.RLock()
	defer d.lock.RUnlock()
	return len(d.items)
}

// Strings returns a slice of all the keys present
func (d *TransactionMap) GetKys() []string {
	d.lock.RLock()
	defer d.lock.RUnlock()
	keys := []string{}
	for i := range d.items {
		keys = append(keys, i)
	}
	return keys
}

// BlockchainTransactions returns a slice of all the values present
func (d *TransactionMap) GetVals() []*blockchain.Transaction {
	d.lock.RLock()
	defer d.lock.RUnlock()
	values := []*blockchain.Transaction{}
	for i := range d.items {
		values = append(values, d.items[i])
	}
	return values
}

func (d *TransactionMap) GetUncommittedValsForNext(num int) []*blockchain.Transaction {
	keys := d.GetKys()
	d.lock.RLock()
	defer d.lock.RUnlock()
	sort.Strings(keys)

	values := []*blockchain.Transaction{}

	count := 0
	for _, k := range keys {
		if count < num && !d.items[k].IsCommitted() {
			values = append(values, d.items[k])
			count += 1
		}
	}

	return values
}